# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
  id: ID!
  firstName: String
  lastName: String
  birthDate: DateTime
  email: String
  password: PasswordState
  district: District
  accountType: AccountType
  polls(
    where: PollWhereInput! = {}
    orderBy: [PollOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Poll!]
  pollsCount(where: PollWhereInput! = {}): Int
  responses(
    where: ResponseWhereInput! = {}
    orderBy: [ResponseOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Response!]
  responsesCount(where: ResponseWhereInput! = {}): Int
}

scalar DateTime
  @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

type PasswordState {
  isSet: Boolean!
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  firstName: StringFilter
  lastName: StringFilter
  birthDate: DateTimeNullableFilter
  email: StringFilter
  district: DistrictWhereInput
  accountType: AccountTypeWhereInput
  polls: PollManyRelationFilter
  responses: ResponseManyRelationFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input PollManyRelationFilter {
  every: PollWhereInput
  some: PollWhereInput
  none: PollWhereInput
}

input ResponseManyRelationFilter {
  every: ResponseWhereInput
  some: ResponseWhereInput
  none: ResponseWhereInput
}

input UserOrderByInput {
  id: OrderDirection
  firstName: OrderDirection
  lastName: OrderDirection
  birthDate: OrderDirection
  email: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  firstName: String
  lastName: String
  birthDate: DateTime
  email: String
  password: String
  district: DistrictRelateToOneForUpdateInput
  accountType: AccountTypeRelateToOneForUpdateInput
  polls: PollRelateToManyForUpdateInput
  responses: ResponseRelateToManyForUpdateInput
}

input DistrictRelateToOneForUpdateInput {
  create: DistrictCreateInput
  connect: DistrictWhereUniqueInput
  disconnect: Boolean
}

input AccountTypeRelateToOneForUpdateInput {
  create: AccountTypeCreateInput
  connect: AccountTypeWhereUniqueInput
  disconnect: Boolean
}

input PollRelateToManyForUpdateInput {
  disconnect: [PollWhereUniqueInput!]
  set: [PollWhereUniqueInput!]
  create: [PollCreateInput!]
  connect: [PollWhereUniqueInput!]
}

input ResponseRelateToManyForUpdateInput {
  disconnect: [ResponseWhereUniqueInput!]
  set: [ResponseWhereUniqueInput!]
  create: [ResponseCreateInput!]
  connect: [ResponseWhereUniqueInput!]
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  firstName: String
  lastName: String
  birthDate: DateTime
  email: String
  password: String
  district: DistrictRelateToOneForCreateInput
  accountType: AccountTypeRelateToOneForCreateInput
  polls: PollRelateToManyForCreateInput
  responses: ResponseRelateToManyForCreateInput
}

input DistrictRelateToOneForCreateInput {
  create: DistrictCreateInput
  connect: DistrictWhereUniqueInput
}

input AccountTypeRelateToOneForCreateInput {
  create: AccountTypeCreateInput
  connect: AccountTypeWhereUniqueInput
}

input PollRelateToManyForCreateInput {
  create: [PollCreateInput!]
  connect: [PollWhereUniqueInput!]
}

input ResponseRelateToManyForCreateInput {
  create: [ResponseCreateInput!]
  connect: [ResponseWhereUniqueInput!]
}

type District {
  id: ID!
  name: String
  users: User
}

input DistrictWhereUniqueInput {
  id: ID
}

input DistrictWhereInput {
  AND: [DistrictWhereInput!]
  OR: [DistrictWhereInput!]
  NOT: [DistrictWhereInput!]
  id: IDFilter
  name: StringFilter
  users: UserWhereInput
}

input DistrictOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input DistrictUpdateInput {
  name: String
  users: UserRelateToOneForUpdateInput
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input DistrictUpdateArgs {
  where: DistrictWhereUniqueInput!
  data: DistrictUpdateInput!
}

input DistrictCreateInput {
  name: String
  users: UserRelateToOneForCreateInput
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type AccountType {
  id: ID!
  name: String
  users: User
}

input AccountTypeWhereUniqueInput {
  id: ID
}

input AccountTypeWhereInput {
  AND: [AccountTypeWhereInput!]
  OR: [AccountTypeWhereInput!]
  NOT: [AccountTypeWhereInput!]
  id: IDFilter
  name: StringFilter
  users: UserWhereInput
}

input AccountTypeOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input AccountTypeUpdateInput {
  name: String
  users: UserRelateToOneForUpdateInput
}

input AccountTypeUpdateArgs {
  where: AccountTypeWhereUniqueInput!
  data: AccountTypeUpdateInput!
}

input AccountTypeCreateInput {
  name: String
  users: UserRelateToOneForCreateInput
}

type Poll {
  id: ID!
  question: String
  createdAt: DateTime
  createdBy: User
  access: PollAccess
  answers(
    where: AnswerWhereInput! = {}
    orderBy: [AnswerOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Answer!]
  answersCount(where: AnswerWhereInput! = {}): Int
  tags(
    where: TagWhereInput! = {}
    orderBy: [TagOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Tag!]
  tagsCount(where: TagWhereInput! = {}): Int
}

input PollWhereUniqueInput {
  id: ID
}

input PollWhereInput {
  AND: [PollWhereInput!]
  OR: [PollWhereInput!]
  NOT: [PollWhereInput!]
  id: IDFilter
  question: StringFilter
  createdAt: DateTimeNullableFilter
  createdBy: UserWhereInput
  access: PollAccessWhereInput
  answers: AnswerManyRelationFilter
  tags: TagManyRelationFilter
}

input AnswerManyRelationFilter {
  every: AnswerWhereInput
  some: AnswerWhereInput
  none: AnswerWhereInput
}

input TagManyRelationFilter {
  every: TagWhereInput
  some: TagWhereInput
  none: TagWhereInput
}

input PollOrderByInput {
  id: OrderDirection
  question: OrderDirection
  createdAt: OrderDirection
}

input PollUpdateInput {
  question: String
  createdAt: DateTime
  createdBy: UserRelateToOneForUpdateInput
  access: PollAccessRelateToOneForUpdateInput
  answers: AnswerRelateToManyForUpdateInput
  tags: TagRelateToManyForUpdateInput
}

input PollAccessRelateToOneForUpdateInput {
  create: PollAccessCreateInput
  connect: PollAccessWhereUniqueInput
  disconnect: Boolean
}

input AnswerRelateToManyForUpdateInput {
  disconnect: [AnswerWhereUniqueInput!]
  set: [AnswerWhereUniqueInput!]
  create: [AnswerCreateInput!]
  connect: [AnswerWhereUniqueInput!]
}

input TagRelateToManyForUpdateInput {
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

input PollUpdateArgs {
  where: PollWhereUniqueInput!
  data: PollUpdateInput!
}

input PollCreateInput {
  question: String
  createdAt: DateTime
  createdBy: UserRelateToOneForCreateInput
  access: PollAccessRelateToOneForCreateInput
  answers: AnswerRelateToManyForCreateInput
  tags: TagRelateToManyForCreateInput
}

input PollAccessRelateToOneForCreateInput {
  create: PollAccessCreateInput
  connect: PollAccessWhereUniqueInput
}

input AnswerRelateToManyForCreateInput {
  create: [AnswerCreateInput!]
  connect: [AnswerWhereUniqueInput!]
}

input TagRelateToManyForCreateInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type PollAccess {
  id: ID!
  level: String
  polls: Poll
}

input PollAccessWhereUniqueInput {
  id: ID
}

input PollAccessWhereInput {
  AND: [PollAccessWhereInput!]
  OR: [PollAccessWhereInput!]
  NOT: [PollAccessWhereInput!]
  id: IDFilter
  level: StringNullableFilter
  polls: PollWhereInput
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input PollAccessOrderByInput {
  id: OrderDirection
  level: OrderDirection
}

input PollAccessUpdateInput {
  level: String
  polls: PollRelateToOneForUpdateInput
}

input PollRelateToOneForUpdateInput {
  create: PollCreateInput
  connect: PollWhereUniqueInput
  disconnect: Boolean
}

input PollAccessUpdateArgs {
  where: PollAccessWhereUniqueInput!
  data: PollAccessUpdateInput!
}

input PollAccessCreateInput {
  level: String
  polls: PollRelateToOneForCreateInput
}

input PollRelateToOneForCreateInput {
  create: PollCreateInput
  connect: PollWhereUniqueInput
}

type Answer {
  id: ID!
  answer: String
  poll: Poll
  responses(
    where: ResponseWhereInput! = {}
    orderBy: [ResponseOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Response!]
  responsesCount(where: ResponseWhereInput! = {}): Int
}

input AnswerWhereUniqueInput {
  id: ID
}

input AnswerWhereInput {
  AND: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
  id: IDFilter
  answer: StringFilter
  poll: PollWhereInput
  responses: ResponseManyRelationFilter
}

input AnswerOrderByInput {
  id: OrderDirection
  answer: OrderDirection
}

input AnswerUpdateInput {
  answer: String
  poll: PollRelateToOneForUpdateInput
  responses: ResponseRelateToManyForUpdateInput
}

input AnswerUpdateArgs {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateInput!
}

input AnswerCreateInput {
  answer: String
  poll: PollRelateToOneForCreateInput
  responses: ResponseRelateToManyForCreateInput
}

type Response {
  id: ID!
  answer: Answer
  user: User
}

input ResponseWhereUniqueInput {
  id: ID
}

input ResponseWhereInput {
  AND: [ResponseWhereInput!]
  OR: [ResponseWhereInput!]
  NOT: [ResponseWhereInput!]
  id: IDFilter
  answer: AnswerWhereInput
  user: UserWhereInput
}

input ResponseOrderByInput {
  id: OrderDirection
}

input ResponseUpdateInput {
  answer: AnswerRelateToOneForUpdateInput
  user: UserRelateToOneForUpdateInput
}

input AnswerRelateToOneForUpdateInput {
  create: AnswerCreateInput
  connect: AnswerWhereUniqueInput
  disconnect: Boolean
}

input ResponseUpdateArgs {
  where: ResponseWhereUniqueInput!
  data: ResponseUpdateInput!
}

input ResponseCreateInput {
  answer: AnswerRelateToOneForCreateInput
  user: UserRelateToOneForCreateInput
}

input AnswerRelateToOneForCreateInput {
  create: AnswerCreateInput
  connect: AnswerWhereUniqueInput
}

type Tag {
  id: ID!
  name: String
  polls(
    where: PollWhereInput! = {}
    orderBy: [PollOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Poll!]
  pollsCount(where: PollWhereInput! = {}): Int
}

input TagWhereUniqueInput {
  id: ID
}

input TagWhereInput {
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
  id: IDFilter
  name: StringFilter
  polls: PollManyRelationFilter
}

input TagOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input TagUpdateInput {
  name: String
  polls: PollRelateToManyForUpdateInput
}

input TagUpdateArgs {
  where: TagWhereUniqueInput!
  data: TagUpdateInput!
}

input TagCreateInput {
  name: String
  polls: PollRelateToManyForCreateInput
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(
    url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
  )

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createDistrict(data: DistrictCreateInput!): District
  createDistricts(data: [DistrictCreateInput!]!): [District]
  updateDistrict(
    where: DistrictWhereUniqueInput!
    data: DistrictUpdateInput!
  ): District
  updateDistricts(data: [DistrictUpdateArgs!]!): [District]
  deleteDistrict(where: DistrictWhereUniqueInput!): District
  deleteDistricts(where: [DistrictWhereUniqueInput!]!): [District]
  createAccountType(data: AccountTypeCreateInput!): AccountType
  createAccountTypes(data: [AccountTypeCreateInput!]!): [AccountType]
  updateAccountType(
    where: AccountTypeWhereUniqueInput!
    data: AccountTypeUpdateInput!
  ): AccountType
  updateAccountTypes(data: [AccountTypeUpdateArgs!]!): [AccountType]
  deleteAccountType(where: AccountTypeWhereUniqueInput!): AccountType
  deleteAccountTypes(where: [AccountTypeWhereUniqueInput!]!): [AccountType]
  createPoll(data: PollCreateInput!): Poll
  createPolls(data: [PollCreateInput!]!): [Poll]
  updatePoll(where: PollWhereUniqueInput!, data: PollUpdateInput!): Poll
  updatePolls(data: [PollUpdateArgs!]!): [Poll]
  deletePoll(where: PollWhereUniqueInput!): Poll
  deletePolls(where: [PollWhereUniqueInput!]!): [Poll]
  createPollAccess(data: PollAccessCreateInput!): PollAccess
  createPollAccesses(data: [PollAccessCreateInput!]!): [PollAccess]
  updatePollAccess(
    where: PollAccessWhereUniqueInput!
    data: PollAccessUpdateInput!
  ): PollAccess
  updatePollAccesses(data: [PollAccessUpdateArgs!]!): [PollAccess]
  deletePollAccess(where: PollAccessWhereUniqueInput!): PollAccess
  deletePollAccesses(where: [PollAccessWhereUniqueInput!]!): [PollAccess]
  createAnswer(data: AnswerCreateInput!): Answer
  createAnswers(data: [AnswerCreateInput!]!): [Answer]
  updateAnswer(where: AnswerWhereUniqueInput!, data: AnswerUpdateInput!): Answer
  updateAnswers(data: [AnswerUpdateArgs!]!): [Answer]
  deleteAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteAnswers(where: [AnswerWhereUniqueInput!]!): [Answer]
  createResponse(data: ResponseCreateInput!): Response
  createResponses(data: [ResponseCreateInput!]!): [Response]
  updateResponse(
    where: ResponseWhereUniqueInput!
    data: ResponseUpdateInput!
  ): Response
  updateResponses(data: [ResponseUpdateArgs!]!): [Response]
  deleteResponse(where: ResponseWhereUniqueInput!): Response
  deleteResponses(where: [ResponseWhereUniqueInput!]!): [Response]
  createTag(data: TagCreateInput!): Tag
  createTags(data: [TagCreateInput!]!): [Tag]
  updateTag(where: TagWhereUniqueInput!, data: TagUpdateInput!): Tag
  updateTags(data: [TagUpdateArgs!]!): [Tag]
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteTags(where: [TagWhereUniqueInput!]!): [Tag]
  endSession: Boolean!
  authenticateUserWithPassword(
    email: String!
    password: String!
  ): UserAuthenticationWithPasswordResult
  createInitialUser(
    data: CreateInitialUserInput!
  ): UserAuthenticationWithPasswordSuccess!
}

union UserAuthenticationWithPasswordResult =
    UserAuthenticationWithPasswordSuccess
  | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  firstName: String
  lastName: String
  birthDate: DateTime
  email: String
  password: String
  district: DistrictRelateToOneForCreateInput
}

type Query {
  users(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  districts(
    where: DistrictWhereInput! = {}
    orderBy: [DistrictOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [District!]
  district(where: DistrictWhereUniqueInput!): District
  districtsCount(where: DistrictWhereInput! = {}): Int
  accountTypes(
    where: AccountTypeWhereInput! = {}
    orderBy: [AccountTypeOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [AccountType!]
  accountType(where: AccountTypeWhereUniqueInput!): AccountType
  accountTypesCount(where: AccountTypeWhereInput! = {}): Int
  polls(
    where: PollWhereInput! = {}
    orderBy: [PollOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Poll!]
  poll(where: PollWhereUniqueInput!): Poll
  pollsCount(where: PollWhereInput! = {}): Int
  pollAccesses(
    where: PollAccessWhereInput! = {}
    orderBy: [PollAccessOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [PollAccess!]
  pollAccess(where: PollAccessWhereUniqueInput!): PollAccess
  pollAccessesCount(where: PollAccessWhereInput! = {}): Int
  answers(
    where: AnswerWhereInput! = {}
    orderBy: [AnswerOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Answer!]
  answer(where: AnswerWhereUniqueInput!): Answer
  answersCount(where: AnswerWhereInput! = {}): Int
  responses(
    where: ResponseWhereInput! = {}
    orderBy: [ResponseOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Response!]
  response(where: ResponseWhereUniqueInput!): Response
  responsesCount(where: ResponseWhereInput! = {}): Int
  tags(
    where: TagWhereInput! = {}
    orderBy: [TagOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Tag!]
  tag(where: TagWhereUniqueInput!): Tag
  tagsCount(where: TagWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  enableSignout: Boolean!
  enableSessionItem: Boolean!
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  isOrderable: Boolean!
  isFilterable: Boolean!
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum QueryMode {
  default
  insensitive
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
